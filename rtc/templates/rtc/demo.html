<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgoraPlay - Video Call Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="m-0 p-0 font-sans overflow-hidden">
    <!-- Pre-call Screen -->
    <div class="flex items-center justify-center h-screen bg-gradient-to-br from-gray-800 to-gray-900" id="pre-call-screen">
        <div class="bg-gray-800 rounded-2xl p-12 shadow-2xl text-center w-96">
            <h1 class="text-white text-3xl font-medium mb-8">Join a Video Call</h1>
            <div class="mb-6 text-left">
                <label for="channel-input" class="block text-gray-300 mb-2 text-sm font-medium">Channel Name</label>
                <input
                    type="text"
                    id="channel-input"
                    placeholder="Enter channel name"
                    value="demo"
                    class="w-full px-4 py-3 bg-gray-700 text-white border-2 border-gray-600 rounded-lg text-base outline-none focus:border-blue-500 transition-colors"
                >
            </div>
            <button class="w-full bg-blue-600 text-white py-3 rounded-lg text-lg font-medium hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors" id="join-btn">Join Call</button>
        </div>
    </div>

    <!-- Video Call Screen -->
    <div class="hidden fixed inset-0 bg-gray-900" id="video-call-screen">
        <!-- Main Video (Remote Participant) -->
        <div id="main-video" class="absolute inset-0 bg-black flex items-center justify-center cursor-pointer hover:opacity-95 transition-opacity">
            <div class="absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none" id="remote-name">Waiting for others...</div>
        </div>

        <!-- Self View (Local - Bottom Right) -->
        <div id="self-view" class="absolute bottom-20 right-4 w-[280px] h-[160px] bg-black rounded-lg overflow-hidden shadow-xl border-2 border-gray-700 mb-4 cursor-grab active:cursor-grabbing transition-all duration-200 hover:border-blue-500">
            <div class="absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none" id="self-name">You</div>
        </div>

        <!-- Bottom Control Bar -->
        <div class="absolute bottom-0 left-0 right-0 h-20 bg-gray-900/95 backdrop-blur-sm flex items-center justify-between px-6 border-t border-gray-800">
            <!-- Left: Meeting Info -->
            <div class="flex items-center gap-3 text-white">
                <span class="text-sm font-medium" id="meeting-time">00:00</span>
                <span class="text-gray-500">â€¢</span>
                <span class="text-sm font-medium" id="meeting-code"></span>
            </div>

            <!-- Center: Controls -->
            <div class="flex items-center gap-3">
                <button class="w-12 h-12 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center transition-colors" id="toggle-mic" title="Microphone">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
                    </svg>
                </button>
                <button class="w-12 h-12 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center transition-colors" id="toggle-camera" title="Camera">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z" />
                    </svg>
                </button>
                <button class="w-12 h-12 rounded-full bg-red-600 hover:bg-red-700 flex items-center justify-center transition-colors" id="leave-call-btn" title="Leave call">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 3.75v4.5m0-4.5h-4.5m4.5 0-6 6m3 12c-8.284 0-15-6.716-15-15V4.5A2.25 2.25 0 0 1 4.5 2.25h1.372c.516 0 .966.351 1.091.852l1.106 4.423c.11.44-.054.902-.417 1.173l-1.293.97a1.062 1.062 0 0 0-.38 1.21 12.035 12.035 0 0 0 7.143 7.143c.441.162.928-.004 1.21-.38l.97-1.293a1.125 1.125 0 0 1 1.173-.417l4.423 1.106c.5.125.852.575.852 1.091V19.5a2.25 2.25 0 0 1-2.25 2.25h-2.25Z" />
                    </svg>
                </button>
            </div>

            <!-- Right: More Options -->
            <div class="flex items-center gap-2">
                <button class="w-10 h-10 rounded-full hover:bg-gray-700 flex items-center justify-center transition-colors text-white" title="Meeting details">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z" />
                    </svg>
                </button>
                <button class="w-10 h-10 rounded-full hover:bg-gray-700 flex items-center justify-center transition-colors text-white" title="Show everyone">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 19.128a9.38 9.38 0 0 0 2.625.372 9.337 9.337 0 0 0 4.121-.952 4.125 4.125 0 0 0-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 0 1 8.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0 1 11.964-3.07M12 6.375a3.375 3.375 0 1 1-6.75 0 3.375 3.375 0 0 1 6.75 0Zm8.25 2.25a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z" />
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Agora Web SDK -->
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.23.1.js"></script>

    <script>
        // Enable Agora SDK debug logging
        AgoraRTC.setLogLevel(0); // 0 = DEBUG, 1 = INFO, 2 = WARNING, 3 = ERROR, 4 = NONE

        // Initialize Agora client
        const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
        console.log('Agora client initialized');

        let localTracks = {
            videoTrack: null,
            audioTrack: null
        };

        let remoteUsers = {};

        // Media state
        let isVideoEnabled = true;
        let isAudioEnabled = true;

        // View state - track which video is in main view
        let isLocalInMainView = false; // false = remote in main, true = local in main

        // DOM elements
        const preCallScreen = document.getElementById('pre-call-screen');
        const videoCallScreen = document.getElementById('video-call-screen');
        const channelInput = document.getElementById('channel-input');
        const joinBtn = document.getElementById('join-btn');
        const leaveCallBtn = document.getElementById('leave-call-btn');
        const mainVideo = document.getElementById('main-video');
        const selfView = document.getElementById('self-view');
        const remoteName = document.getElementById('remote-name');
        const selfName = document.getElementById('self-name');
        const meetingCode = document.getElementById('meeting-code');
        const meetingTime = document.getElementById('meeting-time');
        const toggleMic = document.getElementById('toggle-mic');
        const toggleCamera = document.getElementById('toggle-camera');

        // Meeting timer
        let meetingStartTime = null;
        let timerInterval = null;

        // Start meeting timer
        function startTimer() {
            meetingStartTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - meetingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                meetingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Stop meeting timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            meetingTime.textContent = '00:00';
        }

        // SVG icons
        const icons = {
            videoOn: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z" /></svg>',
            videoOff: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M12 18.75H4.5a2.25 2.25 0 0 1-2.25-2.25V9m12.841 9.091L16.5 19.5m-1.409-1.409c.407-.407.659-.97.659-1.591v-9a2.25 2.25 0 0 0-2.25-2.25h-9c-.621 0-1.184.252-1.591.659m12.182 12.182L2.909 5.909M1.5 4.5l1.409 1.409" /></svg>',
            micOn: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>',
            micOff: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>'
        };

        // Toggle camera
        async function toggleCameraControl() {
            if (!localTracks.videoTrack) return;

            if (isVideoEnabled) {
                await localTracks.videoTrack.setEnabled(false);
                isVideoEnabled = false;
                toggleCamera.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.classList.add('bg-red-600', 'hover:bg-red-700');
                toggleCamera.innerHTML = icons.videoOff;
                console.log('Camera disabled');
            } else {
                await localTracks.videoTrack.setEnabled(true);
                isVideoEnabled = true;
                toggleCamera.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleCamera.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.innerHTML = icons.videoOn;
                console.log('Camera enabled');
            }
        }

        // Toggle microphone
        async function toggleMicControl() {
            if (!localTracks.audioTrack) return;

            if (isAudioEnabled) {
                await localTracks.audioTrack.setEnabled(false);
                isAudioEnabled = false;
                toggleMic.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.classList.add('bg-red-600', 'hover:bg-red-700');
                toggleMic.innerHTML = icons.micOff;
                console.log('Microphone muted');
            } else {
                await localTracks.audioTrack.setEnabled(true);
                isAudioEnabled = true;
                toggleMic.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleMic.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.innerHTML = icons.micOn;
                console.log('Microphone unmuted');
            }
        }

        // Toggle view - swap between local and remote video
        function toggleVideoView() {
            // Get the first remote user
            const remoteUser = Object.values(remoteUsers)[0];

            // Only allow toggle if we have both local and remote tracks
            if (!localTracks.videoTrack || !remoteUser || !remoteUser.videoTrack) {
                console.log('Cannot toggle view - missing video tracks');
                return;
            }

            // Clear both containers
            mainVideo.innerHTML = '';
            selfView.innerHTML = '';

            if (isLocalInMainView) {
                // Switch back: Local to small view, Remote to main view
                localTracks.videoTrack.play(selfView);
                remoteUser.videoTrack.play(mainVideo);

                // Update labels
                const selfLabel = document.createElement('div');
                selfLabel.id = 'self-name';
                selfLabel.className = 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                selfLabel.textContent = 'You';
                selfView.appendChild(selfLabel);

                const remoteLabel = document.createElement('div');
                remoteLabel.id = 'remote-name';
                remoteLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                remoteLabel.textContent = `Participant ${remoteUser.uid}`;
                mainVideo.appendChild(remoteLabel);

                isLocalInMainView = false;
                console.log('Switched to remote in main view');
            } else {
                // Switch: Local to main view, Remote to small view
                localTracks.videoTrack.play(mainVideo);
                remoteUser.videoTrack.play(selfView);

                // Update labels
                const mainLabel = document.createElement('div');
                mainLabel.id = 'remote-name';
                mainLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                mainLabel.textContent = 'You';
                mainVideo.appendChild(mainLabel);

                const smallLabel = document.createElement('div');
                smallLabel.id = 'self-name';
                smallLabel.className = 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                smallLabel.textContent = `Participant ${remoteUser.uid}`;
                selfView.appendChild(smallLabel);

                isLocalInMainView = true;
                console.log('Switched to local in main view');
            }
        }

        // Join channel
        async function joinChannel() {
            const channelName = channelInput.value.trim();

            if (!channelName) {
                alert('Please enter a channel name');
                return;
            }

            try {
                joinBtn.disabled = true;
                joinBtn.textContent = 'Joining...';

                // Fetch token from Agora API
                console.log('Fetching token for channel:', channelName);
                const response = await fetch(`/api/agora/token/?channel=${channelName}`);
                const data = await response.json();
                console.log('Token response:', data);

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to get token');
                }

                // Join the channel
                const uid = await client.join(
                    data.appId,
                    data.channel,
                    data.token,
                    data.uid
                );
                console.log('Successfully joined channel with UID:', uid);

                // Create local tracks
                console.log('Creating local tracks...');
                localTracks.audioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                localTracks.videoTrack = await AgoraRTC.createCameraVideoTrack();
                console.log('Local tracks created');

                // Play local video in self-view
                localTracks.videoTrack.play(selfView);
                console.log('Local video playing in self-view');

                // Publish local tracks
                await client.publish([localTracks.audioTrack, localTracks.videoTrack]);
                console.log('Tracks published successfully');

                // Switch to video call screen
                preCallScreen.classList.add('hidden');
                videoCallScreen.classList.remove('hidden');

                // Update meeting info
                meetingCode.textContent = channelName;
                startTimer();

                // Reset button states
                isVideoEnabled = true;
                isAudioEnabled = true;
                toggleCamera.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleCamera.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.innerHTML = icons.videoOn;
                toggleMic.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleMic.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.innerHTML = icons.micOn;

            } catch (error) {
                console.error('Error joining channel:', error);
                alert(`Error: ${error.message}`);
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Call';

                // Clean up on error
                if (localTracks.audioTrack) {
                    localTracks.audioTrack.close();
                    localTracks.audioTrack = null;
                }
                if (localTracks.videoTrack) {
                    localTracks.videoTrack.close();
                    localTracks.videoTrack = null;
                }
            }
        }

        // Leave channel
        async function leaveChannel() {
            try {
                // Stop and close local tracks
                if (localTracks.audioTrack) {
                    localTracks.audioTrack.stop();
                    localTracks.audioTrack.close();
                }
                if (localTracks.videoTrack) {
                    localTracks.videoTrack.stop();
                    localTracks.videoTrack.close();
                }

                // Remove all remote users
                remoteUsers = {};

                // Leave the channel
                await client.leave();

                console.log('Left the channel');

                // Stop timer
                stopTimer();

                // Switch back to pre-call screen
                videoCallScreen.classList.add('hidden');
                preCallScreen.classList.remove('hidden');

                // Reset join button
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Call';

                // Clear main video
                mainVideo.innerHTML = '<div class="absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm" id="remote-name">Waiting for others...</div>';

            } catch (error) {
                console.error('Error leaving channel:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Handle user published (remote user starts streaming)
        client.on("user-published", async (user, mediaType) => {
            await client.subscribe(user, mediaType);
            console.log("Subscribe success");

            if (mediaType === "video") {
                console.log("Playing remote video for user:", user.uid);
                remoteUsers[user.uid] = user;

                // Play remote video in main-video container
                mainVideo.innerHTML = '';
                user.videoTrack.play(mainVideo);
                console.log("Remote video playing in main view");

                // Update participant name
                const nameLabel = document.createElement('div');
                nameLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm';
                nameLabel.textContent = `Participant ${user.uid}`;
                mainVideo.appendChild(nameLabel);
            }

            if (mediaType === "audio") {
                console.log("Playing remote audio for user:", user.uid);
                user.audioTrack.play();
            }
        });

        // Handle user unpublished
        client.on("user-unpublished", (user, mediaType) => {
            if (mediaType === "video") {
                console.log("Remote user unpublished video");
                delete remoteUsers[user.uid];
                mainVideo.innerHTML = '<div class="absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm" id="remote-name">Waiting for others...</div>';
            }
        });

        // Event listeners
        joinBtn.addEventListener('click', joinChannel);
        leaveCallBtn.addEventListener('click', leaveChannel);
        toggleCamera.addEventListener('click', toggleCameraControl);
        toggleMic.addEventListener('click', toggleMicControl);

        // Allow Enter key to join
        channelInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !joinBtn.disabled) {
                joinChannel();
            }
        });

        // ========================================
        // Drag and Drop Self-View with Snap-to-Corner
        // ========================================

        let isDragging = false;
        let hasDragged = false; // Track if user actually dragged (vs just clicked)
        let dragStartX = 0;
        let dragStartY = 0;
        let selfViewStartX = 0;
        let selfViewStartY = 0;

        // Corner positions configuration
        const PADDING = 16; // Distance from edges (matches Tailwind's spacing)
        const BOTTOM_BAR_HEIGHT = 80; // Height of control bar (20 in Tailwind units = 80px)
        const CORNER_MARGIN = 16; // Additional margin for bottom corners

        // Get corner positions based on viewport
        function getCornerPositions() {
            const rect = selfView.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            return {
                'bottom-right': {
                    bottom: BOTTOM_BAR_HEIGHT + CORNER_MARGIN,
                    right: PADDING,
                    top: null,
                    left: null
                },
                'bottom-left': {
                    bottom: BOTTOM_BAR_HEIGHT + CORNER_MARGIN,
                    left: PADDING,
                    top: null,
                    right: null
                },
                'top-right': {
                    top: PADDING,
                    right: PADDING,
                    bottom: null,
                    left: null
                },
                'top-left': {
                    top: PADDING,
                    left: PADDING,
                    bottom: null,
                    right: null
                }
            };
        }

        // Find nearest corner based on current position
        function findNearestCorner(x, y) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const rect = selfView.getBoundingClientRect();

            // Calculate center point of the element
            const centerX = x + rect.width / 2;
            const centerY = y + rect.height / 2;

            // Determine which quadrant the center is in
            const isRight = centerX > viewportWidth / 2;
            const isBottom = centerY > viewportHeight / 2;

            if (isBottom && isRight) return 'bottom-right';
            if (isBottom && !isRight) return 'bottom-left';
            if (!isBottom && isRight) return 'top-right';
            return 'top-left';
        }

        // Apply corner position to self-view
        function snapToCorner(corner) {
            const positions = getCornerPositions();
            const pos = positions[corner];

            // Remove all position classes
            selfView.style.top = '';
            selfView.style.bottom = '';
            selfView.style.left = '';
            selfView.style.right = '';

            // Apply new position
            if (pos.top !== null) selfView.style.top = `${pos.top}px`;
            if (pos.bottom !== null) selfView.style.bottom = `${pos.bottom}px`;
            if (pos.left !== null) selfView.style.left = `${pos.left}px`;
            if (pos.right !== null) selfView.style.right = `${pos.right}px`;

            // Save preference to localStorage
            localStorage.setItem('selfViewCorner', corner);
            console.log(`Self-view snapped to: ${corner}`);
        }

        // Mouse down - start dragging
        selfView.addEventListener('mousedown', (e) => {
            isDragging = true;
            hasDragged = false;

            const rect = selfView.getBoundingClientRect();
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            selfViewStartX = rect.left;
            selfViewStartY = rect.top;

            // Remove transition during drag for smooth movement
            selfView.style.transition = 'none';

            // Prevent text selection while dragging
            e.preventDefault();
        });

        // Mouse move - drag the element
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;

            // If moved more than 5px, consider it a drag (not a click)
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                hasDragged = true;
            }

            const newX = selfViewStartX + deltaX;
            const newY = selfViewStartY + deltaY;

            // Apply position
            selfView.style.top = `${newY}px`;
            selfView.style.bottom = 'auto';
            selfView.style.left = `${newX}px`;
            selfView.style.right = 'auto';
        });

        // Mouse up - snap to nearest corner or toggle view if clicked
        document.addEventListener('mouseup', (e) => {
            if (!isDragging) return;

            isDragging = false;

            // Re-enable transition for smooth snap
            selfView.style.transition = 'all 0.2s';

            if (hasDragged) {
                // User dragged - snap to corner
                const rect = selfView.getBoundingClientRect();
                const nearestCorner = findNearestCorner(rect.left, rect.top);
                snapToCorner(nearestCorner);
            } else {
                // User clicked - toggle view
                toggleVideoView();
            }
        });

        // Touch support for mobile
        selfView.addEventListener('touchstart', (e) => {
            isDragging = true;
            hasDragged = false;

            const touch = e.touches[0];
            const rect = selfView.getBoundingClientRect();

            dragStartX = touch.clientX;
            dragStartY = touch.clientY;
            selfViewStartX = rect.left;
            selfViewStartY = rect.top;

            selfView.style.transition = 'none';
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;

            const touch = e.touches[0];
            const deltaX = touch.clientX - dragStartX;
            const deltaY = touch.clientY - dragStartY;

            // If moved more than 5px, consider it a drag (not a tap)
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                hasDragged = true;
            }

            const newX = selfViewStartX + deltaX;
            const newY = selfViewStartY + deltaY;

            selfView.style.top = `${newY}px`;
            selfView.style.bottom = 'auto';
            selfView.style.left = `${newX}px`;
            selfView.style.right = 'auto';
        });

        document.addEventListener('touchend', (e) => {
            if (!isDragging) return;

            isDragging = false;
            selfView.style.transition = 'all 0.2s';

            if (hasDragged) {
                // User dragged - snap to corner
                const rect = selfView.getBoundingClientRect();
                const nearestCorner = findNearestCorner(rect.left, rect.top);
                snapToCorner(nearestCorner);
            } else {
                // User tapped - toggle view
                toggleVideoView();
            }
        });

        // Click handler for main video - toggle view
        mainVideo.addEventListener('click', (e) => {
            // Only toggle if clicking on the video container (not during drag)
            if (!isDragging) {
                toggleVideoView();
            }
        });

        // Load saved position on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedCorner = localStorage.getItem('selfViewCorner') || 'bottom-right';
            snapToCorner(savedCorner);
        });

        // Reposition on window resize
        window.addEventListener('resize', () => {
            const savedCorner = localStorage.getItem('selfViewCorner') || 'bottom-right';
            snapToCorner(savedCorner);
        });
    </script>
</body>
</html>
