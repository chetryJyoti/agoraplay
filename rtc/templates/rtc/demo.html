<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgoraPlay - Video Call Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="m-0 p-0 font-sans overflow-hidden">
    <!-- Pre-call Screen -->
    <div class="flex items-center justify-center h-screen bg-gradient-to-br from-gray-800 to-gray-900" id="pre-call-screen">
        <div class="bg-gray-800 rounded-2xl p-12 shadow-2xl text-center w-96">
            <h1 class="text-white text-3xl font-medium mb-8">Join a Video Call</h1>
            <div class="mb-6 text-left">
                <label for="channel-input" class="block text-gray-300 mb-2 text-sm font-medium">Channel Name</label>
                <input
                    type="text"
                    id="channel-input"
                    placeholder="Enter channel name"
                    value="demo"
                    class="w-full px-4 py-3 bg-gray-700 text-white border-2 border-gray-600 rounded-lg text-base outline-none focus:border-blue-500 transition-colors"
                >
            </div>
            <button class="w-full bg-blue-600 text-white py-3 rounded-lg text-lg font-medium hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors" id="join-btn">Join Call</button>
        </div>
    </div>

    <!-- Video Call Screen -->
    <div class="hidden fixed inset-0 bg-gray-900" id="video-call-screen">
        <!-- Main Video (Remote Participant) -->
        <div id="main-video" class="absolute inset-0 bg-black flex items-center justify-center transition-opacity">
            <div class="absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none" id="remote-name">Waiting for others...</div>
        </div>

        <!-- Self View (Local - Bottom Right) - Hidden by default, shown when remote user joins -->
        <div id="self-view" class="hidden absolute bottom-20 right-4 w-[280px] h-[160px] bg-black rounded-lg overflow-hidden shadow-xl border-2 border-gray-700 mb-4 cursor-grab active:cursor-grabbing transition-all duration-200 hover:border-blue-500">
            <div class="absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none" id="self-name">You</div>
        </div>

        <!-- Bottom Control Bar -->
        <div class="absolute bottom-0 left-0 right-0 h-20 bg-gray-900/95 backdrop-blur-sm flex items-center justify-between px-6 border-t border-gray-800">
            <!-- Left: Meeting Info -->
            <div class="flex items-center gap-3 text-white">
                <span class="text-sm font-medium" id="meeting-time">00:00</span>
                <span class="text-gray-500">â€¢</span>
                <span class="text-sm font-medium" id="meeting-code"></span>
                <!-- Recording Indicator -->
                <div id="recording-indicator" class="hidden flex items-center gap-2 ml-2 px-3 py-1 bg-red-600/20 rounded-full border border-red-600">
                    <div class="w-2 h-2 bg-red-600 rounded-full animate-pulse"></div>
                    <span class="text-xs font-medium text-red-400">Recording</span>
                </div>
            </div>

            <!-- Center: Controls -->
            <div class="flex items-center gap-3">
                <button class="w-12 h-12 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center transition-colors" id="toggle-mic" title="Microphone">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
                    </svg>
                </button>
                <button class="w-12 h-12 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center transition-colors" id="toggle-camera" title="Camera">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z" />
                    </svg>
                </button>
                <button class="w-12 h-12 rounded-full bg-gray-700 hover:bg-gray-600 flex items-center justify-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed" id="toggle-recording" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 0 1 9 14.437V9.564Z" />
                    </svg>
                </button>
                <button class="w-12 h-12 rounded-full bg-red-600 hover:bg-red-700 flex items-center justify-center transition-colors" id="leave-call-btn" title="Leave call">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M20.25 3.75v4.5m0-4.5h-4.5m4.5 0-6 6m3 12c-8.284 0-15-6.716-15-15V4.5A2.25 2.25 0 0 1 4.5 2.25h1.372c.516 0 .966.351 1.091.852l1.106 4.423c.11.44-.054.902-.417 1.173l-1.293.97a1.062 1.062 0 0 0-.38 1.21 12.035 12.035 0 0 0 7.143 7.143c.441.162.928-.004 1.21-.38l.97-1.293a1.125 1.125 0 0 1 1.173-.417l4.423 1.106c.5.125.852.575.852 1.091V19.5a2.25 2.25 0 0 1-2.25 2.25h-2.25Z" />
                    </svg>
                </button>
            </div>

            <!-- Right: More Options -->
            <div class="flex items-center gap-2">
                <!-- Encryption Info Button -->
                <div class="relative">
                    <button id="encryption-btn" class="w-10 h-10 rounded-full hover:bg-gray-700 flex items-center justify-center transition-colors text-white" title="Meeting details">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75m-3-7.036A11.959 11.959 0 0 1 3.598 6 11.99 11.99 0 0 0 3 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285Z" />
                        </svg>
                    </button>
                    <!-- Encryption Tooltip -->
                    <div id="encryption-tooltip" class="hidden absolute bottom-12 right-0 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg whitespace-nowrap text-sm z-50">
                        <div class="flex items-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 text-green-400">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
                            </svg>
                            <span>This call is end-to-end encrypted</span>
                        </div>
                        <!-- Tooltip Arrow -->
                        <div class="absolute -bottom-1 right-4 w-2 h-2 bg-gray-800 rotate-45"></div>
                    </div>
                </div>
                <button class="relative w-10 h-10 rounded-full hover:bg-gray-700 flex items-center justify-center transition-colors text-white" title="Show everyone">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 19.128a9.38 9.38 0 0 0 2.625.372 9.337 9.337 0 0 0 4.121-.952 4.125 4.125 0 0 0-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 0 1 8.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0 1 11.964-3.07M12 6.375a3.375 3.375 0 1 1-6.75 0 3.375 3.375 0 0 1 6.75 0Zm8.25 2.25a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z" />
                    </svg>
                    <!-- Participant Count Badge -->
                    <span id="participant-count" class="absolute -top-1 -right-1 bg-blue-600 text-white text-xs font-bold rounded-full w-5 h-5 flex items-center justify-center">1</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Agora Web SDK -->
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.23.1.js"></script>
    <!-- Video UI Interactions -->
    <script src="video-ui.js"></script>


    <script>
        // Enable Agora SDK debug logging
        AgoraRTC.setLogLevel(0); // 0 = DEBUG, 1 = INFO, 2 = WARNING, 3 = ERROR, 4 = NONE

        // Initialize Agora client
        const client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
        console.log('Agora client initialized');

        let localTracks = {
            videoTrack: null,
            audioTrack: null
        };

        let remoteUsers = {};

        // Media state
        let isVideoEnabled = true;
        let isAudioEnabled = true;

        // Recording state
        let isRecording = false;
        let recordingResourceId = null;
        let recordingSid = null;
        let currentChannel = null;
        const RECORDING_UID = "999999"; // Unique UID for recording service

        // View state - track which video is in main view
        let isLocalInMainView = false; // false = remote in main, true = local in main

        // DOM elements
        const preCallScreen = document.getElementById('pre-call-screen');
        const videoCallScreen = document.getElementById('video-call-screen');
        const channelInput = document.getElementById('channel-input');
        const joinBtn = document.getElementById('join-btn');
        const leaveCallBtn = document.getElementById('leave-call-btn');
        const mainVideo = document.getElementById('main-video');
        const selfView = document.getElementById('self-view');
        const remoteName = document.getElementById('remote-name');
        const selfName = document.getElementById('self-name');
        const meetingCode = document.getElementById('meeting-code');
        const meetingTime = document.getElementById('meeting-time');
        const toggleMic = document.getElementById('toggle-mic');
        const toggleCamera = document.getElementById('toggle-camera');
        const toggleRecording = document.getElementById('toggle-recording');
        const recordingIndicator = document.getElementById('recording-indicator');
        const participantCount = document.getElementById('participant-count');

        // Meeting timer
        let meetingStartTime = null;
        let timerInterval = null;

        // Start meeting timer
        function startTimer() {
            meetingStartTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - meetingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                meetingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Stop meeting timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            meetingTime.textContent = '00:00';
        }

        // Update participant count
        function updateParticipantCount() {
            // Count: 1 (local user) + number of remote users
            const totalCount = 1 + Object.keys(remoteUsers).length;
            participantCount.textContent = totalCount;
            console.log(`Participant count updated: ${totalCount}`);
        }

        // Generate initials from user ID
        function getInitials(uid) {
            if (uid === 0 || uid === 'local') {
                return 'You';
            }
            // For participant IDs, use "P" + last 2 digits
            const uidStr = uid.toString();
            return 'P' + uidStr.slice(-2);
        }

        // Generate random pastel color based on UID
        function getAvatarColor(uid) {
            const colors = [
                '#60A5FA', // blue
                '#34D399', // green
                '#FBBF24', // yellow
                '#F87171', // red
                '#A78BFA', // purple
                '#FB923C', // orange
                '#EC4899', // pink
                '#14B8A6', // teal
            ];
            const index = (typeof uid === 'number' ? uid : 0) % colors.length;
            return colors[index];
        }

        // Create avatar placeholder
        function createAvatarPlaceholder(uid, isMainView = true) {
            const initials = getInitials(uid);
            const color = getAvatarColor(uid);
            const size = isMainView ? 'w-32 h-32 text-4xl' : 'w-20 h-20 text-2xl';

            const avatar = document.createElement('div');
            avatar.className = `avatar-placeholder absolute inset-0 flex items-center justify-center bg-gray-800`;
            avatar.innerHTML = `
                <div class="${size} rounded-full flex items-center justify-center font-bold text-white" style="background-color: ${color}">
                    ${initials}
                </div>
            `;
            return avatar;
        }

        // Show avatar in container
        function showAvatar(container, uid, isMainView = true) {
            // Remove existing avatar if any
            const existingAvatar = container.querySelector('.avatar-placeholder');
            if (existingAvatar) {
                existingAvatar.remove();
            }

            // Create and add new avatar
            const avatar = createAvatarPlaceholder(uid, isMainView);
            container.appendChild(avatar);
        }

        // Hide avatar from container
        function hideAvatar(container) {
            const existingAvatar = container.querySelector('.avatar-placeholder');
            if (existingAvatar) {
                existingAvatar.remove();
            }
        }

        // SVG icons
        const icons = {
            videoOn: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z" /></svg>',
            videoOff: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M12 18.75H4.5a2.25 2.25 0 0 1-2.25-2.25V9m12.841 9.091L16.5 19.5m-1.409-1.409c.407-.407.659-.97.659-1.591v-9a2.25 2.25 0 0 0-2.25-2.25h-9c-.621 0-1.184.252-1.591.659m12.182 12.182L2.909 5.909M1.5 4.5l1.409 1.409" /></svg>',
            micOn: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>',
            micOff: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-white"><path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>'
        };

        // Toggle camera
        async function toggleCameraControl() {
            if (!localTracks.videoTrack) return;

            if (isVideoEnabled) {
                await localTracks.videoTrack.setEnabled(false);
                isVideoEnabled = false;
                toggleCamera.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.classList.add('bg-red-600', 'hover:bg-red-700');
                toggleCamera.innerHTML = icons.videoOff;

                // Determine which container the local user is in
                const hasRemoteUsers = Object.keys(remoteUsers).length > 0;
                const container = (hasRemoteUsers && !isLocalInMainView) ? selfView : mainVideo;
                const isMainViewContainer = container === mainVideo;

                // Show avatar placeholder
                showAvatar(container, 'local', isMainViewContainer);

                console.log('Camera disabled - showing avatar');
            } else {
                await localTracks.videoTrack.setEnabled(true);
                isVideoEnabled = true;
                toggleCamera.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleCamera.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.innerHTML = icons.videoOn;

                // Determine which container the local user is in
                const hasRemoteUsers = Object.keys(remoteUsers).length > 0;
                const container = (hasRemoteUsers && !isLocalInMainView) ? selfView : mainVideo;

                // Hide avatar placeholder
                hideAvatar(container);

                console.log('Camera enabled - hiding avatar');
            }
        }

        // Toggle microphone
        async function toggleMicControl() {
            if (!localTracks.audioTrack) return;

            if (isAudioEnabled) {
                await localTracks.audioTrack.setEnabled(false);
                isAudioEnabled = false;
                toggleMic.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.classList.add('bg-red-600', 'hover:bg-red-700');
                toggleMic.innerHTML = icons.micOff;
                console.log('Microphone muted');
            } else {
                await localTracks.audioTrack.setEnabled(true);
                isAudioEnabled = true;
                toggleMic.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleMic.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.innerHTML = icons.micOn;
                console.log('Microphone unmuted');
            }
        }

        // Start cloud recording
        async function startRecording() {
            if (isRecording || !currentChannel) {
                console.log('Cannot start recording - already recording or no channel');
                return;
            }

            try {
                toggleRecording.disabled = true;
                console.log('Starting recording for channel:', currentChannel);

                const response = await fetch('/api/agora/recording/start/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        channel: currentChannel,
                        uid: RECORDING_UID
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to start recording');
                }

                console.log('Recording started:', data);

                // Save recording session info
                recordingResourceId = data.resourceId;
                recordingSid = data.sid;
                isRecording = true;

                // Update UI
                toggleRecording.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                toggleRecording.classList.add('bg-red-600', 'hover:bg-red-700');
                toggleRecording.title = 'Stop Recording';
                recordingIndicator.classList.remove('hidden');
                recordingIndicator.classList.add('flex');

                console.log('Recording UI updated - recording active');

            } catch (error) {
                console.error('Error starting recording:', error);
                alert(`Failed to start recording: ${error.message}`);
            } finally {
                toggleRecording.disabled = false;
            }
        }

        // Stop cloud recording
        async function stopRecording() {
            if (!isRecording || !recordingResourceId || !recordingSid) {
                console.log('Cannot stop recording - not recording');
                return;
            }

            try {
                toggleRecording.disabled = true;
                console.log('Stopping recording...');

                const response = await fetch('/api/agora/recording/stop/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        resourceId: recordingResourceId,
                        sid: recordingSid,
                        channel: currentChannel,
                        uid: RECORDING_UID
                    })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to stop recording');
                }

                console.log('Recording stopped:', data);

                // Reset recording state
                recordingResourceId = null;
                recordingSid = null;
                isRecording = false;

                // Update UI
                toggleRecording.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleRecording.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleRecording.title = 'Start Recording';
                recordingIndicator.classList.remove('flex');
                recordingIndicator.classList.add('hidden');

                alert('Recording stopped! Video will be uploaded to your S3 bucket.');
                console.log('Recording UI updated - recording stopped');

            } catch (error) {
                console.error('Error stopping recording:', error);
                alert(`Failed to stop recording: ${error.message}`);
            } finally {
                toggleRecording.disabled = false;
            }
        }

        // Toggle recording on/off
        async function toggleRecordingControl() {
            if (isRecording) {
                await stopRecording();
            } else {
                await startRecording();
            }
        }

        // Toggle view - swap between local and remote video
        function toggleVideoView() {
            // Get the first remote user
            const remoteUser = Object.values(remoteUsers)[0];

            // Only allow toggle if we have a remote user
            if (!remoteUser) {
                console.log('Cannot toggle view - no remote user');
                return;
            }

            // Clear both containers
            mainVideo.innerHTML = '';
            selfView.innerHTML = '';

            if (isLocalInMainView) {
                // Switch back: Local to small view, Remote to main view

                // Show local video or avatar in small view
                if (isVideoEnabled && localTracks.videoTrack) {
                    localTracks.videoTrack.play(selfView);
                } else {
                    showAvatar(selfView, 'local', false);
                }

                // Show remote video or avatar in main view
                if (remoteUser.videoTrack) {
                    remoteUser.videoTrack.play(mainVideo);
                } else {
                    showAvatar(mainVideo, remoteUser.uid, true);
                }

                // Update labels
                const selfLabel = document.createElement('div');
                selfLabel.id = 'self-name';
                selfLabel.className = 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                selfLabel.textContent = 'You';
                selfView.appendChild(selfLabel);

                const remoteLabel = document.createElement('div');
                remoteLabel.id = 'remote-name';
                remoteLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                remoteLabel.textContent = `Participant ${remoteUser.uid}`;
                mainVideo.appendChild(remoteLabel);

                isLocalInMainView = false;
                console.log('Switched to remote in main view');
            } else {
                // Switch: Local to main view, Remote to small view

                // Show local video or avatar in main view
                if (isVideoEnabled && localTracks.videoTrack) {
                    localTracks.videoTrack.play(mainVideo);
                } else {
                    showAvatar(mainVideo, 'local', true);
                }

                // Show remote video or avatar in small view
                if (remoteUser.videoTrack) {
                    remoteUser.videoTrack.play(selfView);
                } else {
                    showAvatar(selfView, remoteUser.uid, false);
                }

                // Update labels
                const mainLabel = document.createElement('div');
                mainLabel.id = 'remote-name';
                mainLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                mainLabel.textContent = 'You';
                mainVideo.appendChild(mainLabel);

                const smallLabel = document.createElement('div');
                smallLabel.id = 'self-name';
                smallLabel.className = 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                smallLabel.textContent = `Participant ${remoteUser.uid}`;
                selfView.appendChild(smallLabel);

                isLocalInMainView = true;
                console.log('Switched to local in main view');
            }
        }

        // Join channel
        async function joinChannel() {
            const channelName = channelInput.value.trim();

            if (!channelName) {
                alert('Please enter a channel name');
                return;
            }

            try {
                joinBtn.disabled = true;
                joinBtn.textContent = 'Joining...';

                // Fetch token from Agora API
                console.log('Fetching token for channel:', channelName);
                const response = await fetch(`/api/agora/token/?channel=${channelName}`);
                const data = await response.json();
                console.log('Token response:', data);

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to get token');
                }

                // Join the channel
                const uid = await client.join(
                    data.appId,
                    data.channel,
                    data.token,
                    data.uid
                );
                console.log('Successfully joined channel with UID:', uid);

                // Create local tracks
                console.log('Creating local tracks...');
                localTracks.audioTrack = await AgoraRTC.createMicrophoneAudioTrack();
                localTracks.videoTrack = await AgoraRTC.createCameraVideoTrack();
                console.log('Local tracks created');

                // Play local video in main view initially (when alone in call)
                mainVideo.innerHTML = '';
                localTracks.videoTrack.play(mainVideo);

                // Add "You" label to main video
                const youLabel = document.createElement('div');
                youLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                youLabel.textContent = 'You (Waiting for others...)';
                mainVideo.appendChild(youLabel);
                console.log('Local video playing in main view');

                // Publish local tracks
                await client.publish([localTracks.audioTrack, localTracks.videoTrack]);
                console.log('Tracks published successfully');

                // Switch to video call screen
                preCallScreen.classList.add('hidden');
                videoCallScreen.classList.remove('hidden');

                // Update meeting info
                meetingCode.textContent = channelName;
                currentChannel = channelName; // Store channel name for recording
                startTimer();

                // Reset button states
                isVideoEnabled = true;
                isAudioEnabled = true;
                toggleCamera.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleCamera.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleCamera.innerHTML = icons.videoOn;
                toggleMic.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleMic.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleMic.innerHTML = icons.micOn;

                // Update participant count (initially just local user)
                updateParticipantCount();

            } catch (error) {
                console.error('Error joining channel:', error);
                alert(`Error: ${error.message}`);
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Call';

                // Clean up on error
                if (localTracks.audioTrack) {
                    localTracks.audioTrack.close();
                    localTracks.audioTrack = null;
                }
                if (localTracks.videoTrack) {
                    localTracks.videoTrack.close();
                    localTracks.videoTrack = null;
                }
            }
        }

        // Leave channel
        async function leaveChannel() {
            try {
                // Stop recording if active
                if (isRecording) {
                    await stopRecording();
                }

                // Stop and close local tracks
                if (localTracks.audioTrack) {
                    localTracks.audioTrack.stop();
                    localTracks.audioTrack.close();
                }
                if (localTracks.videoTrack) {
                    localTracks.videoTrack.stop();
                    localTracks.videoTrack.close();
                }

                // Remove all remote users
                remoteUsers = {};

                // Leave the channel
                await client.leave();

                console.log('Left the channel');

                // Stop timer
                stopTimer();

                // Reset recording state
                isRecording = false;
                recordingResourceId = null;
                recordingSid = null;
                currentChannel = null;
                toggleRecording.classList.remove('bg-red-600', 'hover:bg-red-700');
                toggleRecording.classList.add('bg-gray-700', 'hover:bg-gray-600');
                toggleRecording.title = 'Start Recording';
                recordingIndicator.classList.remove('flex');
                recordingIndicator.classList.add('hidden');

                // Hide self-view
                selfView.classList.add('hidden');

                // Switch back to pre-call screen
                videoCallScreen.classList.add('hidden');
                preCallScreen.classList.remove('hidden');

                // Reset join button
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join Call';

                // Clear main video
                mainVideo.innerHTML = '<div class="absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm" id="remote-name">Waiting for others...</div>';

                // Reset view state
                isLocalInMainView = false;

                // Reset participant count
                participantCount.textContent = '1';

            } catch (error) {
                console.error('Error leaving channel:', error);
                alert(`Error: ${error.message}`);
            }
        }

        // Handle user published (remote user starts streaming)
        client.on("user-published", async (user, mediaType) => {
            await client.subscribe(user, mediaType);
            console.log("Subscribe success");

            if (mediaType === "video") {
                console.log("Playing remote video for user:", user.uid);

                // Store or update user
                if (!remoteUsers[user.uid]) {
                    remoteUsers[user.uid] = user;
                    // Update participant count only for new users
                    updateParticipantCount();
                } else {
                    remoteUsers[user.uid] = user;
                }

                // Show self-view when remote user joins
                selfView.classList.remove('hidden');

                // Enable click on main video (for toggling)
                mainVideo.classList.add('cursor-pointer', 'hover:opacity-95');

                // Move local video to self-view (if not already there)
                if (localTracks.videoTrack && !isLocalInMainView) {
                    selfView.innerHTML = '';

                    // Show avatar if local video is disabled, otherwise show video
                    if (!isVideoEnabled) {
                        showAvatar(selfView, 'local', false);
                    } else {
                        localTracks.videoTrack.play(selfView);
                    }

                    // Add "You" label to self-view
                    const selfLabel = document.createElement('div');
                    selfLabel.id = 'self-name';
                    selfLabel.className = 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                    selfLabel.textContent = 'You';
                    selfView.appendChild(selfLabel);
                }

                // Play remote video in main-video container
                mainVideo.innerHTML = '';
                user.videoTrack.play(mainVideo);

                // Hide any avatar that might be showing
                hideAvatar(mainVideo);

                console.log("Remote video playing in main view");

                // Update participant name
                const nameLabel = document.createElement('div');
                nameLabel.id = 'remote-name';
                nameLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                nameLabel.textContent = `Participant ${user.uid}`;
                mainVideo.appendChild(nameLabel);
            }

            if (mediaType === "audio") {
                console.log("Playing remote audio for user:", user.uid);

                // Add user to remoteUsers if not already there (audio-only participant)
                if (!remoteUsers[user.uid]) {
                    remoteUsers[user.uid] = user;
                    updateParticipantCount();
                }

                user.audioTrack.play();
            }
        });

        // Handle user unpublished
        client.on("user-unpublished", (user, mediaType) => {
            if (mediaType === "video") {
                console.log("Remote user unpublished video (camera off):", user.uid);

                // Check if user still has audio track (they're still in the call, just camera off)
                const hasAudio = user.audioTrack && user.audioTrack.isPlaying;

                if (hasAudio) {
                    // User is still in call, just turned off camera - show avatar
                    console.log("User still in call, showing avatar");

                    // Determine which container the user is in
                    const userInMainView = !isLocalInMainView;
                    const container = userInMainView ? mainVideo : selfView;

                    // Show avatar placeholder
                    showAvatar(container, user.uid, userInMainView);

                    // Keep the user label
                    const nameLabel = document.createElement('div');
                    nameLabel.id = userInMainView ? 'remote-name' : 'self-name';
                    nameLabel.className = userInMainView
                        ? 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none'
                        : 'absolute bottom-2 left-2 bg-black/60 text-white px-2 py-1 rounded text-xs pointer-events-none';
                    nameLabel.textContent = `Participant ${user.uid}`;
                    container.appendChild(nameLabel);
                } else {
                    // User completely left - remove them
                    console.log("User left the call");
                    delete remoteUsers[user.uid];

                    // Check if there are any remaining remote users
                    const remainingUsers = Object.keys(remoteUsers).length;

                    if (remainingUsers === 0) {
                        // No more remote users - hide self-view and show local in main view
                        selfView.classList.add('hidden');

                        // Disable click on main video (no toggle when alone)
                        mainVideo.classList.remove('cursor-pointer', 'hover:opacity-95');

                        // Reset view state
                        isLocalInMainView = false;

                        // Move local video back to main view
                        if (localTracks.videoTrack) {
                            mainVideo.innerHTML = '';

                            // Show avatar if local video is disabled, otherwise show video
                            if (!isVideoEnabled) {
                                showAvatar(mainVideo, 'local', true);
                            } else {
                                localTracks.videoTrack.play(mainVideo);
                            }

                            // Add "You" label
                            const youLabel = document.createElement('div');
                            youLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                            youLabel.textContent = 'You (Waiting for others...)';
                            mainVideo.appendChild(youLabel);
                        }
                    } else {
                        // There are still other remote users, show the next one
                        const nextUser = Object.values(remoteUsers)[0];
                        if (nextUser) {
                            mainVideo.innerHTML = '';

                            if (nextUser.videoTrack) {
                                // User has video
                                nextUser.videoTrack.play(mainVideo);
                            } else {
                                // User doesn't have video (camera off) - show avatar
                                showAvatar(mainVideo, nextUser.uid, true);
                            }

                            const nameLabel = document.createElement('div');
                            nameLabel.id = 'remote-name';
                            nameLabel.className = 'absolute bottom-4 left-4 bg-black/60 text-white px-3 py-1 rounded text-sm pointer-events-none';
                            nameLabel.textContent = `Participant ${nextUser.uid}`;
                            mainVideo.appendChild(nameLabel);
                        }
                    }

                    // Update participant count
                    updateParticipantCount();
                }
            }
        });

        // Event listeners
        joinBtn.addEventListener('click', joinChannel);
        leaveCallBtn.addEventListener('click', leaveChannel);
        toggleCamera.addEventListener('click', toggleCameraControl);
        toggleMic.addEventListener('click', toggleMicControl);
        toggleRecording.addEventListener('click', toggleRecordingControl);

        // Allow Enter key to join
        channelInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !joinBtn.disabled) {
                joinChannel();
            }
        });

        // ========================================
        // Encryption Tooltip Toggle
        // ========================================

        const encryptionBtn = document.getElementById('encryption-btn');
        const encryptionTooltip = document.getElementById('encryption-tooltip');

        // Toggle tooltip on click
        encryptionBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            encryptionTooltip.classList.toggle('hidden');
        });

        // Close tooltip when clicking outside
        document.addEventListener('click', (e) => {
            if (!encryptionTooltip.classList.contains('hidden') &&
                !encryptionBtn.contains(e.target) &&
                !encryptionTooltip.contains(e.target)) {
                encryptionTooltip.classList.add('hidden');
            }
        });

        // ========================================
        // Drag and Drop Self-View with Snap-to-Corner
        // ========================================

        let isDragging = false;
        let hasDragged = false; // Track if user actually dragged (vs just clicked)
        let dragStartX = 0;
        let dragStartY = 0;
        let selfViewStartX = 0;
        let selfViewStartY = 0;

        // Corner positions configuration
        const PADDING = 16; // Distance from edges (matches Tailwind's spacing)
        const BOTTOM_BAR_HEIGHT = 80; // Height of control bar (20 in Tailwind units = 80px)
        const CORNER_MARGIN = 16; // Additional margin for bottom corners

        // Get corner positions based on viewport
        function getCornerPositions() {
            const rect = selfView.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            return {
                'bottom-right': {
                    bottom: BOTTOM_BAR_HEIGHT + CORNER_MARGIN,
                    right: PADDING,
                    top: null,
                    left: null
                },
                'bottom-left': {
                    bottom: BOTTOM_BAR_HEIGHT + CORNER_MARGIN,
                    left: PADDING,
                    top: null,
                    right: null
                },
                'top-right': {
                    top: PADDING,
                    right: PADDING,
                    bottom: null,
                    left: null
                },
                'top-left': {
                    top: PADDING,
                    left: PADDING,
                    bottom: null,
                    right: null
                }
            };
        }

        // Find nearest corner based on current position
        function findNearestCorner(x, y) {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const rect = selfView.getBoundingClientRect();

            // Calculate center point of the element
            const centerX = x + rect.width / 2;
            const centerY = y + rect.height / 2;

            // Determine which quadrant the center is in
            const isRight = centerX > viewportWidth / 2;
            const isBottom = centerY > viewportHeight / 2;

            if (isBottom && isRight) return 'bottom-right';
            if (isBottom && !isRight) return 'bottom-left';
            if (!isBottom && isRight) return 'top-right';
            return 'top-left';
        }

        // Apply corner position to self-view
        function snapToCorner(corner) {
            const positions = getCornerPositions();
            const pos = positions[corner];

            // Remove all position classes
            selfView.style.top = '';
            selfView.style.bottom = '';
            selfView.style.left = '';
            selfView.style.right = '';

            // Apply new position
            if (pos.top !== null) selfView.style.top = `${pos.top}px`;
            if (pos.bottom !== null) selfView.style.bottom = `${pos.bottom}px`;
            if (pos.left !== null) selfView.style.left = `${pos.left}px`;
            if (pos.right !== null) selfView.style.right = `${pos.right}px`;

            // Save preference to localStorage
            localStorage.setItem('selfViewCorner', corner);
            console.log(`Self-view snapped to: ${corner}`);
        }

        // Mouse down - start dragging
        selfView.addEventListener('mousedown', (e) => {
            isDragging = true;
            hasDragged = false;

            const rect = selfView.getBoundingClientRect();
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            selfViewStartX = rect.left;
            selfViewStartY = rect.top;

            // Remove transition during drag for smooth movement
            selfView.style.transition = 'none';

            // Prevent text selection while dragging
            e.preventDefault();
        });

        // Mouse move - drag the element
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;

            // If moved more than 5px, consider it a drag (not a click)
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                hasDragged = true;
            }

            const newX = selfViewStartX + deltaX;
            const newY = selfViewStartY + deltaY;

            // Apply position
            selfView.style.top = `${newY}px`;
            selfView.style.bottom = 'auto';
            selfView.style.left = `${newX}px`;
            selfView.style.right = 'auto';
        });

        // Mouse up - snap to nearest corner or toggle view if clicked
        document.addEventListener('mouseup', (e) => {
            if (!isDragging) return;

            isDragging = false;

            // Re-enable transition for smooth snap
            selfView.style.transition = 'all 0.2s';

            if (hasDragged) {
                // User dragged - snap to corner
                const rect = selfView.getBoundingClientRect();
                const nearestCorner = findNearestCorner(rect.left, rect.top);
                snapToCorner(nearestCorner);
            } else {
                // User clicked - toggle view
                toggleVideoView();
            }
        });

        // Touch support for mobile
        selfView.addEventListener('touchstart', (e) => {
            isDragging = true;
            hasDragged = false;

            const touch = e.touches[0];
            const rect = selfView.getBoundingClientRect();

            dragStartX = touch.clientX;
            dragStartY = touch.clientY;
            selfViewStartX = rect.left;
            selfViewStartY = rect.top;

            selfView.style.transition = 'none';
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;

            const touch = e.touches[0];
            const deltaX = touch.clientX - dragStartX;
            const deltaY = touch.clientY - dragStartY;

            // If moved more than 5px, consider it a drag (not a tap)
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                hasDragged = true;
            }

            const newX = selfViewStartX + deltaX;
            const newY = selfViewStartY + deltaY;

            selfView.style.top = `${newY}px`;
            selfView.style.bottom = 'auto';
            selfView.style.left = `${newX}px`;
            selfView.style.right = 'auto';
        });

        document.addEventListener('touchend', (e) => {
            if (!isDragging) return;

            isDragging = false;
            selfView.style.transition = 'all 0.2s';

            if (hasDragged) {
                // User dragged - snap to corner
                const rect = selfView.getBoundingClientRect();
                const nearestCorner = findNearestCorner(rect.left, rect.top);
                snapToCorner(nearestCorner);
            } else {
                // User tapped - toggle view
                toggleVideoView();
            }
        });

        // Click handler for main video - toggle view
        mainVideo.addEventListener('click', (e) => {
            // Only toggle if clicking on the video container (not during drag)
            if (!isDragging) {
                toggleVideoView();
            }
        });

        // Load saved position on page load
        window.addEventListener('DOMContentLoaded', () => {
            const savedCorner = localStorage.getItem('selfViewCorner') || 'bottom-right';
            snapToCorner(savedCorner);
        });

        // Reposition on window resize
        window.addEventListener('resize', () => {
            const savedCorner = localStorage.getItem('selfViewCorner') || 'bottom-right';
            snapToCorner(savedCorner);
        });
    </script>
</body>
</html>
